# ADR-0006: Router — источники конфигурации и состояния модулей

## Контекст

Новый слой маршрутизации должен уметь выбирать реализацию модуля по паззлу и
роли, учитывая многочисленные источники конфигурации: флаги CLI, переменные
окружения, профили запуска и `config.toml`. Дополнительно нужно контролировать
состояния rollout'а (`shadow`, `canary`, `default`, `required`, `disabled`,
`deprecated`) и запрещать эксперименты в CI.

## Решение

- Добавлен модуль `src/orchestrator/router.py` с функцией
  `resolve(puzzle_kind, role, profile, env)`.
- Источники приоритетов: CLI/ENV → `modules.<puzzle_kind>.<role>.by_profile` →
  базовый блок `modules.<puzzle_kind>.<role>` → ошибка, если ничего не задано.
- Router проверяет наличие каталогов `src/puzzles/<puzzle_kind>/<role>/<impl>`
  и при отсутствии реализации использует `allow_fallback` (по умолчанию
  возвращается `legacy`).
- Профиль `ci` запрещает состояния `shadow` и `canary` — Router поднимет
  исключение до запуска пайплайна.
- Возвращается объект `ResolvedModule` с `module_id`, `decision_source`,
  `fallback_used` и другими метаданными для журналирования.

## Последствия

- Выбор реализации стал детерминированным и воспроизводимым: одинаковый набор
  входных параметров приводит к одному и тому же `module_id`.
- Оркестратор может логировать журнал решений (`results["modules"]`), что
  упрощает дебаг и аудит.
- Добавление новых паззлов/ролей требует обновить `config.toml` и положить
  заглушки `__init__.py`, иначе Router выдаст понятную ошибку.
- Fallback на `legacy` позволяет безопасно включать Nova по профилям/ENV без
  риска падения пайплайна при отсутствии новой реализации.
